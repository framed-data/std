<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>framed.std.core documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Std 0.1.9 API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><a href="index.html"><span class="inner">Namespaces</span></a></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>framed</span></div></div></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>std</span></div></div></li><li class="depth-3 branch current"><a href="framed.std.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-3 branch"><a href="framed.std.io.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>io</span></div></a></li><li class="depth-3 branch"><a href="framed.std.math.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>math</span></div></a></li><li class="depth-3 branch"><a href="framed.std.serialization.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>serialization</span></div></a></li><li class="depth-3"><a href="framed.std.time.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>time</span></div></a></li></ul></div><div class="sidebar" id="vars"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="framed.std.core.html#var-coll-wrap"><div class="inner"><span>coll-wrap</span></div></a></li><li class="depth-1"><a href="framed.std.core.html#var-flip"><div class="inner"><span>flip</span></div></a></li><li class="depth-1"><a href="framed.std.core.html#var-from-edn"><div class="inner"><span>from-edn</span></div></a></li><li class="depth-1"><a href="framed.std.core.html#var-future-loop"><div class="inner"><span>future-loop</span></div></a></li><li class="depth-1"><a href="framed.std.core.html#var-map-from-keys"><div class="inner"><span>map-from-keys</span></div></a></li><li class="depth-1"><a href="framed.std.core.html#var-map-kv"><div class="inner"><span>map-kv</span></div></a></li><li class="depth-1"><a href="framed.std.core.html#var-map-tup"><div class="inner"><span>map-tup</span></div></a></li><li class="depth-1"><a href="framed.std.core.html#var-mapcat"><div class="inner"><span>mapcat</span></div></a></li><li class="depth-1"><a href="framed.std.core.html#var-rand-alphanumeric"><div class="inner"><span>rand-alphanumeric</span></div></a></li><li class="depth-1"><a href="framed.std.core.html#var-rand-int-between"><div class="inner"><span>rand-int-between</span></div></a></li><li class="depth-1"><a href="framed.std.core.html#var-shuffle"><div class="inner"><span>shuffle</span></div></a></li><li class="depth-1"><a href="framed.std.core.html#var-to-edn"><div class="inner"><span>to-edn</span></div></a></li><li class="depth-1"><a href="framed.std.core.html#var-when-assoc"><div class="inner"><span>when-assoc</span></div></a></li><li class="depth-1"><a href="framed.std.core.html#var-when-assoc-in"><div class="inner"><span>when-assoc-in</span></div></a></li><li class="depth-1"><a href="framed.std.core.html#var-zip"><div class="inner"><span>zip</span></div></a></li><li class="depth-1"><a href="framed.std.core.html#var-zipmap-seq"><div class="inner"><span>zipmap-seq</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h2 class="anchor" id="top">framed.std.core</h2><div class="doc"><pre class="plaintext">Utility functions to complement clojure.core
</pre></div><div class="public anchor" id="var-coll-wrap"><h3>coll-wrap</h3><div class="usage"><code>(coll-wrap x-or-xs)</code></div><div class="doc"><pre class="plaintext">Wrap value in a vector if it is not sequential already
Ex:
  (coll-wrap 2)       ; =&gt; [2]
  (coll-wrap [1 2 3]) ; =&gt; [1 2 3]</pre></div></div><div class="public anchor" id="var-flip"><h3>flip</h3><div class="usage"><code>(flip f)</code><code>(flip f y x)</code></div><div class="doc"><pre class="plaintext">Takes two arguments in the reverse order of f (&apos;flips&apos; a function
of two arguments)
If supplied a function with no args, returns a new function
accepting the reversed args

Ex:
  (flip dissoc :foo {:foo 1 :bar 2})
  ; =&gt; {:bar 2}

  (def flipped-dissoc (flip dissoc))
  (flipped-dissoc :foo {:foo 1 :bar 2})
  ; =&gt; {:bar 2}</pre></div></div><div class="public anchor" id="var-from-edn"><h3>from-edn</h3><div class="usage"><code>(from-edn x)</code></div><div class="doc"><pre class="plaintext">Attempt to parse x as EDN, or return nil on failure
</pre></div></div><div class="public anchor" id="var-future-loop"><h3>future-loop</h3><h4 class="type">macro</h4><div class="usage"><code>(future-loop &amp; body)</code></div><div class="doc"><pre class="plaintext">Execute body repeatedly within a future, returning the future
</pre></div></div><div class="public anchor" id="var-map-from-keys"><h3>map-from-keys</h3><h4 class="type">macro</h4><div class="usage"><code>(map-from-keys &amp; forms)</code></div><div class="doc"><pre class="plaintext">Given symbols, e.g. `(map-from-keys foo bar)`,
return a map with those names as keyword keys, and those values:

Ex:
  (map-from-keys foo bar)
  ; =&gt; {:foo foo
        :bar bar}</pre></div></div><div class="public anchor" id="var-map-kv"><h3>map-kv</h3><div class="usage"><code>(map-kv val-fn coll)</code><code>(map-kv key-fn val-fn coll)</code></div><div class="doc"><pre class="plaintext">Same as `map-tup` but returns results in a map
</pre></div></div><div class="public anchor" id="var-map-tup"><h3>map-tup</h3><div class="usage"><code>(map-tup val-fn coll)</code><code>(map-tup key-fn val-fn coll)</code></div><div class="doc"><pre class="plaintext">For all k,v in coll, return a seq of [(key-fn k) (val-fn v)] tuples

Ex:
  (map-tup #(* 2 %) #(* 3 %) {1 2, 3 4, 5 6})
  ; =&gt; ([2 6] [6 12] [10 18])</pre></div></div><div class="public anchor" id="var-mapcat"><h3>mapcat</h3><div class="usage"><code>(mapcat f coll)</code></div><div class="doc"><pre class="plaintext">Like clojure.core/mapcat over a single coll without object
reachability memory issues. This is especially useful when
large seqs are generated by f, but this is a general-purpose
replacement for its clojure.core counterpart.

See <a href="http://clojurian.blogspot.com/2012/11/beware-of-mapcat.html">http://clojurian.blogspot.com/2012/11/beware-of-mapcat.html</a>
    <a href="http://stackoverflow.com/questions/21943577/mapcat-breaking-the-lazyness">http://stackoverflow.com/questions/21943577/mapcat-breaking-the-lazyness</a></pre></div></div><div class="public anchor" id="var-rand-alphanumeric"><h3>rand-alphanumeric</h3><div class="usage"><code>(rand-alphanumeric len)</code></div><div class="doc"><pre class="plaintext">Generate a string of random letters/digits of a given length
</pre></div></div><div class="public anchor" id="var-rand-int-between"><h3>rand-int-between</h3><div class="usage"><code>(rand-int-between min-val max-val)</code></div><div class="doc"><pre class="plaintext">Generate a random int in the inclusive range of min-val to max-val
</pre></div></div><div class="public anchor" id="var-shuffle"><h3>shuffle</h3><div class="usage"><code>(shuffle rng coll)</code></div><div class="doc"><pre class="plaintext">Same as clojure.core/shuffle but accepts source of randomness
for deterministic testing</pre></div></div><div class="public anchor" id="var-to-edn"><h3>to-edn</h3><div class="usage"><code>(to-edn x)</code></div><div class="doc"><pre class="plaintext">pr-str x only if it is truthy, else return nil
</pre></div></div><div class="public anchor" id="var-when-assoc"><h3>when-assoc</h3><div class="usage"><code>(when-assoc coll k v)</code></div><div class="doc"><pre class="plaintext">When v is truthy, assoc it into coll at k. Otherwise return coll
</pre></div></div><div class="public anchor" id="var-when-assoc-in"><h3>when-assoc-in</h3><div class="usage"><code>(when-assoc-in coll ks v)</code></div><div class="doc"><pre class="plaintext">When v is truthy, assoc it into coll at ks. Otherwise return coll
</pre></div></div><div class="public anchor" id="var-zip"><h3>zip</h3><div class="usage"><code>(zip &amp; colls)</code></div><div class="doc"><pre class="plaintext">Zip corresponding elements from two or more colls together
Ex:
  (zip [1 2] [3 4])
  ; =&gt; [[1 3] [2 4]]</pre></div></div><div class="public anchor" id="var-zipmap-seq"><h3>zipmap-seq</h3><div class="usage"><code>(zipmap-seq key-fn val-fn coll)</code></div><div class="doc"><pre class="plaintext">Given a collection `coll`, return a map where for all k in coll,
key of entry is (f k) and value of entry is (g k)

Ex:
  (zipmap-seq #(* 2 %) (* 3 %) [1 2 3])
  ;=&gt; {2 3, 4 6, 6 9}</pre></div></div></div></body></html>